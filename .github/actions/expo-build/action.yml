name: 'Check and Start Build'
description: 'Check for existing builds or start a new one if needed'

inputs:
  project:
    required: true
    type: string
  profile:
    required: true
    type: string
  runtime-version:
    required: true
    type: string
  platforms:
    required: false
    type: string
    default: 'android ios'

outputs:
  android-build-id:
    description: 'Android build ID for tracking the build.'
    value: ${{ steps.check-builds.outputs.android-build-id }}
  android-build-link:
    description: 'Link to the Android build.'
    value: ${{ steps.check-builds.outputs.android-build-link }}
  android-distribution:
    description: 'Distribution channel for the Android build.'
    value: ${{ steps.check-builds.outputs.android-distribution }}
  android-build-profile:
    description: 'Build profile used for Android.'
    value: ${{ steps.check-builds.outputs.android-build-profile }}
  android-runtime-version:
    description: 'Runtime version for Android build.'
    value: ${{ steps.check-builds.outputs.android-runtime-version }}
  android-app-version:
    description: 'App version for Android.'
    value: ${{ steps.check-builds.outputs.android-app-version }}
  android-git-commit:
    description: 'Git commit hash for the Android build.'
    value: ${{ steps.check-builds.outputs.android-git-commit }}
  ios-build-id:
    description: 'iOS build ID for tracking the build.'
    value: ${{ steps.check-builds.outputs.ios-build-id }}
  ios-build-link:
    description: 'Link to the iOS build.'
    value: ${{ steps.check-builds.outputs.ios-build-link }}
  ios-distribution:
    description: 'Distribution channel for the iOS build.'
    value: ${{ steps.check-builds.outputs.ios-distribution }}
  ios-build-profile:
    description: 'Build profile used for iOS.'
    value: ${{ steps.check-builds.outputs.ios-build-profile }}
  ios-runtime-version:
    description: 'Runtime version for iOS build.'
    value: ${{ steps.check-builds.outputs.ios-runtime-version }}
  ios-app-version:
    description: 'App version for iOS.'
    value: ${{ steps.check-builds.outputs.ios-app-version }}
  ios-git-commit:
    description: 'Git commit hash for the iOS build.'
    value: ${{ steps.check-builds.outputs.ios-git-commit }}
  slug:
    description: 'Project slug for Expo tracking.'
    value: ${{ steps.check-builds.outputs.slug }}
  project-id:
    description: 'Project ID for tracking purposes.'
    value: ${{ steps.check-builds.outputs.project-id }}

runs:
  using: 'composite'
  steps:
    - name: Check for Existing Builds or Start New Build
      id: check-builds
      shell: bash
      run: |
        set -euo pipefail

        # Parse platforms into an array safely
        IFS=' ' read -r -a platforms <<< "${{ inputs.platforms }}"
        slugs=()
        project_ids=()

        extract_array_json() {
          # Try to capture the last JSON array block [...] from noisy output
          local raw="$1"
          local arr
          arr=$(printf '%s' "$raw" | perl -0777 -ne 'print $1 if /(\[[\s\S]*\])\s*$/s') || true
          if [ -z "${arr:-}" ]; then
            # Fallback: naive sed from first '[' to last ']'
            arr=$(printf '%s' "$raw" | sed ':a;N;$!ba;s/.*\(\[[^]]*\]\).*/\1/') || true
          fi
          printf '%s' "${arr:-}"
        }

        normalize_array_json() {
          # Accept either an array or a stringified array and return a real array
          local candidate="$1"
          echo "$candidate" | jq empty >/dev/null 2>&1 || {
            echo "Error: Invalid JSON candidate:"
            echo "$candidate"
            exit 1
          }
          echo "$candidate" | jq 'if type=="string" then fromjson else . end'
        }

        for platform in "${platforms[@]}"; do
          echo "=== Checking builds for platform: $platform ==="

          # 1) Ask for existing builds
          build_output=$(yarn nx run ${{ inputs.project }}:build-list \
            --platform "$platform" \
            --buildProfile "${{ inputs.profile }}" \
            --runtimeVersion "${{ inputs["runtime-version"] }}" \
            --limit 1 \
            --json \
            --interactive false 2>&1) || true

          candidate=$(extract_array_json "$build_output")
          if [ -z "$candidate" ]; then
            # As a fallback, try to treat the whole output as JSON (some CLIs return pure JSON)
            candidate="$build_output"
          fi

          # Validate + normalize array (handles double-encoded JSON)
          if ! echo "$candidate" | jq empty >/dev/null 2>&1; then
            echo "Error: Received invalid JSON from build-list for $platform"
            echo "Raw (visible):"; echo "$build_output" | cat -v
            echo "Candidate:"; echo "$candidate"
            exit 1
          fi
          normalized=$(normalize_array_json "$candidate")

          # 2) If no builds, start a new one
          if [[ "$(echo "$normalized" | jq 'length')" -eq 0 ]]; then
            echo "No existing $platform build found for runtime version ${{ inputs["runtime-version"] }}. Starting a new build."
            build_output=$(yarn nx run ${{ inputs.project }}:build \
              --profile "${{ inputs.profile }}" \
              --platform "$platform" \
              --freeze-credentials \
              --interactive false --wait false --json 2>&1) || {
                echo "Error: build command failed for $platform"
                echo "$build_output"
                exit 1
              }

            candidate=$(extract_array_json "$build_output")
            if [ -z "$candidate" ]; then
              candidate="$build_output"
            fi
            echo "$candidate" | jq empty >/dev/null 2>&1 || {
              echo "Error: Invalid JSON from build command for $platform"
              echo "Candidate:"; echo "$candidate"
              exit 1
            }
            normalized=$(normalize_array_json "$candidate")
          else
            echo "$platform build found for runtime version ${{ inputs["runtime-version"] }}."
          fi

          # 3) Ensure first element is an object
          first_type=$(echo "$normalized" | jq -r '.[0] | type? // "null"')
          if [[ "$first_type" != "object" ]]; then
            echo "Error: Expected array of objects; got array of '$first_type' for $platform"
            echo "$normalized" | jq .
            exit 1
          fi

          # 4) Extract fields
          slug=$(echo "$normalized" | jq -r '.[0].project.slug')
          project_id=$(echo "$normalized" | jq -r '.[0].project.id')
          build_id=$(echo "$normalized" | jq -r '.[0].id')
          distribution=$(echo "$normalized" | jq -r '.[0].distribution')
          build_profile=$(echo "$normalized" | jq -r '.[0].buildProfile')
          runtime_version_from_build=$(echo "$normalized" | jq -r '.[0].runtimeVersion')
          app_version=$(echo "$normalized" | jq -r '.[0].appVersion')
          git_commit=$(echo "$normalized" | jq -r '.[0].gitCommitHash')

          # Link (adjust account if needed)
          build_link="https://expo.dev/accounts/better-angels/projects/${slug}/builds/${build_id}"

          # 5) Emit per-platform outputs
          {
            echo "${platform}-build-id=${build_id}"
            echo "${platform}-build-link=${build_link}"
            echo "${platform}-distribution=${distribution}"
            echo "${platform}-build-profile=${build_profile}"
            echo "${platform}-runtime-version=${runtime_version_from_build}"
            echo "${platform}-app-version=${app_version}"
            echo "${platform}-git-commit=${git_commit}"
          } >> "$GITHUB_OUTPUT"

          # Track for cross-platform consistency
          slugs+=("$slug")
          project_ids+=("$project_id")
        done

        # 6) Ensure slugs & project IDs consistent across platforms
        unique_slugs=($(printf '%s\n' "${slugs[@]}" | sort -u))
        unique_project_ids=($(printf '%s\n' "${project_ids[@]}" | sort -u))

        if [ ${#unique_slugs[@]} -ne 1 ]; then
          echo "Error: Different slugs found for platforms: ${slugs[*]}"
          exit 1
        fi
        if [ ${#unique_project_ids[@]} -ne 1 ]; then
          echo "Error: Different project IDs found for platforms: ${project_ids[*]}"
          exit 1
        fi

        # 7) Common outputs
        commit_message=$(git log -1 --pretty=format:"%s" HEAD || echo "")
        {
          echo "commit-message=${commit_message}"
          echo "slug=${unique_slugs[0]}"
          echo "project-id=${unique_project_ids[0]}"
        } >> "$GITHUB_OUTPUT"
