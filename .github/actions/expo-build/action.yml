runs:
  using: 'composite'
  steps:
    - name: Check for Existing Builds or Start New Build
      id: check-builds
      shell: bash
      run: |
        set -euo pipefail

        # Parse platforms into an array safely
        IFS=' ' read -r -a platforms <<< "${{ inputs.platforms }}"
        slugs=()
        project_ids=()

        # --- Helpers ---
        # Extract *all* JSON arrays from noisy output, one per line
        extract_all_arrays() {
          perl -0777 -ne '
            while (/\[ (?: [^\[\]] | (?R) )* \]/gsx) {
              print "$&\n";
            }
          '
        }

        # Return the first candidate array whose first element is an object
        pick_objects_array() {
          while IFS= read -r arr; do
            # validate json
            echo "$arr" | jq empty >/dev/null 2>&1 || continue
            # must be array, non-empty, first element is object
            if echo "$arr" | jq -e 'type=="array" and length>0 and (.[0]|type)=="object"' >/dev/null; then
              echo "$arr"
              return 0
            fi
          done
          return 1
        }

        # Normalize a possibly double-encoded array (string -> fromjson)
        normalize_array_json() {
          local candidate="$1"
          echo "$candidate" | jq 'if type=="string" then fromjson else . end'
        }

        for platform in "${platforms[@]}"; do
          echo "=== Checking builds for platform: $platform ==="

          # 1) Query existing builds
          build_output=$(yarn nx run ${{ inputs.project }}:build-list \
            --platform "$platform" \
            --buildProfile "${{ inputs.profile }}" \
            --runtimeVersion "${{ inputs.runtime-version }}" \
            --limit 1 \
            --json \
            --interactive false 2>&1) || true

          # Try to find the correct array among all arrays in the output
          candidate=$(printf '%s' "$build_output" | extract_all_arrays | pick_objects_array || echo '')
          if [ -z "$candidate" ]; then
            # Fallback: maybe the entire output is just the array or a stringified array
            candidate="$build_output"
          fi

          # Validate + normalize (handles double-encoded)
          if ! echo "$candidate" | jq empty >/dev/null 2>&1; then
            echo "Error: Received invalid JSON from build-list for $platform"
            echo "Raw (visible):"; echo "$build_output" | cat -v
            echo "Candidate:"; echo "$candidate"
            exit 1
          fi
          normalized=$(normalize_array_json "$candidate")

          # 2) If no builds, start a new one
          if [[ "$(echo "$normalized" | jq 'length')" -eq 0 ]]; then
            echo "No existing $platform build found for runtime version ${{ inputs.runtime-version }}. Starting a new build."
            build_output=$(yarn nx run ${{ inputs.project }}:build \
              --profile "${{ inputs.profile }}" \
              --platform "$platform" \
              --freeze-credentials \
              --interactive false --wait false --json 2>&1) || {
                echo "Error: build command failed for $platform"
                echo "$build_output"
                exit 1
              }

            candidate=$(printf '%s' "$build_output" | extract_all_arrays | pick_objects_array || echo '')
            if [ -z "$candidate" ]; then
              candidate="$build_output"
            fi

            if ! echo "$candidate" | jq empty >/dev/null 2>&1; then
              echo "Error: Invalid JSON from build command for $platform"
              echo "Candidate:"; echo "$candidate"
              exit 1
            fi
            normalized=$(normalize_array_json "$candidate")
          else
            echo "$platform build found for runtime version ${{ inputs.runtime-version }}."
          fi

          # 3) Ensure first element is an object (if present)
          first_type=$(echo "$normalized" | jq -r '.[0] | type? // "null"')
          if [[ "$first_type" != "object" ]]; then
            echo "Error: Expected array of objects; got array of '$first_type' for $platform"
            echo "$normalized" | jq .
            exit 1
          fi

          # 4) Extract fields
          slug=$(echo "$normalized" | jq -r '.[0].project.slug')
          project_id=$(echo "$normalized" | jq -r '.[0].project.id')
          build_id=$(echo "$normalized" | jq -r '.[0].id')
          distribution=$(echo "$normalized" | jq -r '.[0].distribution')
          build_profile=$(echo "$normalized" | jq -r '.[0].buildProfile')
          runtime_version_from_build=$(echo "$normalized" | jq -r '.[0].runtimeVersion')
          app_version=$(echo "$normalized" | jq -r '.[0].appVersion')
          git_commit=$(echo "$normalized" | jq -r '.[0].gitCommitHash')

          build_link="https://expo.dev/accounts/better-angels/projects/${slug}/builds/${build_id}"

          {
            echo "${platform}-build-id=${build_id}"
            echo "${platform}-build-link=${build_link}"
            echo "${platform}-distribution=${distribution}"
            echo "${platform}-build-profile=${build_profile}"
            echo "${platform}-runtime-version=${runtime_version_from_build}"
            echo "${platform}-app-version=${app_version}"
            echo "${platform}-git-commit=${git_commit}"
          } >> "$GITHUB_OUTPUT"

          slugs+=("$slug")
          project_ids+=("$project_id")
        done

        # Cross-platform consistency
        unique_slugs=($(printf '%s\n' "${slugs[@]}" | sort -u))
        unique_project_ids=($(printf '%s\n' "${project_ids[@]}" | sort -u))
        if [ ${#unique_slugs[@]} -ne 1 ]; then
          echo "Error: Different slugs found for platforms: ${slugs[*]}"; exit 1; fi
        if [ ${#unique_project_ids[@]} -ne 1 ]; then
          echo "Error: Different project IDs found for platforms: ${project_ids[*]}"; exit 1; fi

        commit_message=$(git log -1 --pretty=format:"%s" HEAD || echo "")
        {
          echo "commit-message=${commit_message}"
          echo "slug=${unique_slugs[0]}"
          echo "project-id=${unique_project_ids[0]}"
        } >> "$GITHUB_OUTPUT"
