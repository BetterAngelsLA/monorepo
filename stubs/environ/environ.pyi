"""
This type stub file was generated by pyright.
"""

from typing import Any
from urllib.parse import ParseResult

"""
Django-environ allows you to utilize 12factor inspired environment
variables to configure your Django application.
"""
Openable = ...
logger = ...

class NoValue:
    """Represent of no value object."""

    def __repr__(self): ...

class Env:
    """Provide scheme-based lookups of environment variables so that each
    caller doesn't have to pass in ``cast`` and ``default`` parameters.

    Usage:::

        import environ
        import os

        env = environ.Env(
            # set casting, default value
            MAIL_ENABLED=(bool, False),
            SMTP_LOGIN=(str, 'DEFAULT')
        )

        # Set the project base directory
        BASE_DIR = os.path.dirname(
            os.path.dirname(os.path.abspath(__file__))
        )

        # Take environment variables from .env file
        environ.Env.read_env(os.path.join(BASE_DIR, '.env'))

        # False if not in os.environ due to casting above
        MAIL_ENABLED = env('MAIL_ENABLED')

        # 'DEFAULT' if not in os.environ due to casting above
        SMTP_LOGIN = env('SMTP_LOGIN')
    """

    ENVIRON = ...
    NOTSET = ...
    BOOLEAN_TRUE_STRINGS = ...
    URL_CLASS = ParseResult
    POSTGRES_FAMILY = ...
    ELASTICSEARCH_FAMILY = ...
    DEFAULT_DATABASE_ENV = ...
    DB_SCHEMES = ...
    _DB_BASE_OPTIONS = ...
    DEFAULT_CACHE_ENV = ...
    CACHE_SCHEMES = ...
    _CACHE_BASE_OPTIONS = ...
    DEFAULT_EMAIL_ENV = ...
    EMAIL_SCHEMES = ...
    _EMAIL_BASE_OPTIONS = ...
    DEFAULT_SEARCH_ENV = ...
    SEARCH_SCHEMES = ...
    CLOUDSQL = ...
    def __init__(self, **scheme) -> None: ...
    def __call__(self, var, cast=..., default=..., parse_default=...): ...
    def __contains__(self, var): ...
    def str(self, var: str, default=..., multiline=...) -> str:
        """
        :rtype: str
        """
        ...
    def bytes(self, var, default=..., encoding=...):
        """
        :rtype: bytes
        """
        ...
    def bool(self, var: str, default=...) -> bool:
        """
        :rtype: bool
        """
        ...
    def int(self, var, default=...):
        """
        :rtype: int
        """
        ...
    def float(self, var, default=...):
        """
        :rtype: float
        """
        ...
    def json(self, var, default=...):
        """
        :returns: Json parsed
        """
        ...
    def list(self, var, cast=..., default=...) -> list[str]:
        """
        :rtype: list
        """
        ...
    def tuple(self, var, cast=..., default=...):
        """
        :rtype: tuple
        """
        ...
    def dict(self, var, cast=..., default=...):
        """
        :rtype: dict
        """
        ...
    def url(self, var, default=...):
        """
        :rtype: urllib.parse.ParseResult
        """
        ...
    def db_url(self, var=..., default=..., engine=...):
        """Returns a config dictionary, defaulting to DATABASE_URL.

        The db method is an alias for db_url.

        :rtype: dict
        """
        ...
    db = ...
    def cache_url(
        self, var=..., default=..., backend=...
    ):  # -> dict[Unknown, Unknown] | dict[str, Unknown]:
        """Returns a config dictionary, defaulting to CACHE_URL.

        The cache method is an alias for cache_url.

        :rtype: dict
        """
        ...
    cache = ...
    def email_url(
        self, var=..., default=..., backend=...
    ):  # -> dict[Unknown, Unknown]:
        """Returns a config dictionary, defaulting to EMAIL_URL.

        The email method is an alias for email_url.

        :rtype: dict
        """
        ...
    email = ...
    def search_url(
        self, var=..., default=..., engine=...
    ):  # -> dict[Unknown, Unknown]:
        """Returns a config dictionary, defaulting to SEARCH_URL.

        :rtype: dict
        """
        ...
    def path(self, var, default=..., **kwargs):  # -> Path:
        """
        :rtype: Path
        """
        ...
    def get_value(self, var, cast=..., default=..., parse_default=...):
        """Return value for given environment variable.

        :param str var:
            Name of variable.
        :param collections.abc.Callable or None cast:
            Type to cast return value as.
        :param default:
             If var not present in environ, return this instead.
        :param bool parse_default:
            Force to parse default.
        :returns: Value from environment or default (if set).
        :rtype: typing.IO[typing.Any]
        """
        ...
    @classmethod
    def parse_value(
        cls, value, cast
    ):  # -> bool | list[Unknown] | tuple[Unknown, ...] | dict[Unknown, Unknown] | float:
        """Parse and cast provided value

        :param value: Stringed value.
        :param cast: Type to cast return value as.

        :returns: Casted value
        """
        ...
    @classmethod
    def db_url_config(cls, url, engine=...):
        """Parse an arbitrary database URL.

        Supports the following URL schemas:

        * PostgreSQL: ``postgres[ql]?://`` or ``p[g]?sql://``
        * PostGIS: ``postgis://``
        * MySQL: ``mysql://`` or ``mysql2://``
        * MySQL (GIS): ``mysqlgis://``
        * MySQL Connector Python from Oracle: ``mysql-connector://``
        * SQLite: ``sqlite://``
        * SQLite with SpatiaLite for GeoDjango: ``spatialite://``
        * Oracle: ``oracle://``
        * Microsoft SQL Server: ``mssql://``
        * PyODBC: ``pyodbc://``
        * Amazon Redshift: ``redshift://``
        * LDAP: ``ldap://``

        :param urllib.parse.ParseResult or str url:
            Database URL to parse.
        :param str or None engine:
            If None, the database engine is evaluates from the ``url``.
        :return: Parsed database URL.
        :rtype: dict
        """
        ...
    @classmethod
    def cache_url_config(
        cls, url, backend=...
    ):  # -> dict[Unknown, Unknown] | dict[str, Unknown]:
        """Parse an arbitrary cache URL.

        :param urllib.parse.ParseResult or str url:
            Cache URL to parse.
        :param str or None backend:
            If None, the backend is evaluates from the ``url``.
        :return: Parsed cache URL.
        :rtype: dict
        """
        ...
    @classmethod
    def email_url_config(cls, url, backend=...):  # -> dict[Unknown, Unknown]:
        """Parse an arbitrary email URL.

        :param urllib.parse.ParseResult or str url:
            Email URL to parse.
        :param str or None backend:
            If None, the backend is evaluates from the ``url``.
        :return: Parsed email URL.
        :rtype: dict
        """
        ...
    @classmethod
    def search_url_config(cls, url, engine=...):  # -> dict[Unknown, Unknown]:
        """Parse an arbitrary search URL.

        :param urllib.parse.ParseResult or str url:
            Search URL to parse.
        :param str or None engine:
            If None, the engine is evaluates from the ``url``.
        :return: Parsed search URL.
        :rtype: dict
        """
        ...
    @classmethod
    def read_env(
        cls, env_file: str, overwrite=..., encoding=..., **overrides: dict[Any, Any]
    ) -> None:
        r"""Read a .env file into os.environ.

        If not given a path to a dotenv path, does filthy magic stack
        backtracking to find the dotenv in the same directory as the file that
        called ``read_env``.

        Existing environment variables take precedent and are NOT overwritten
        by the file content. ``overwrite=True`` will force an overwrite of
        existing environment variables.

        Refs:

        * https://wellfire.co/learn/easier-12-factor-django

        :param env_file: The path to the ``.env`` file your application should
            use. If a path is not provided, `read_env` will attempt to import
            the Django settings module from the Django project root.
        :param overwrite: ``overwrite=True`` will force an overwrite of
            existing environment variables.
        :param encoding: The encoding to use when reading the environment file.
        :param \**overrides: Any additional keyword arguments provided directly
            to read_env will be added to the environment. If the key matches an
            existing environment variable, the value will be overridden.
        """
        ...

class FileAwareEnv(Env):
    """
    First look for environment variables with ``_FILE`` appended. If found,
    their contents will be read from the file system and used instead.

    Use as a drop-in replacement for the standard ``environ.Env``:

    .. code-block:: python

        python env = environ.FileAwareEnv()

    For example, if a ``SECRET_KEY_FILE`` environment variable was set,
    ``env("SECRET_KEY")`` would find the related variable, returning the file
    contents rather than ever looking up a ``SECRET_KEY`` environment variable.
    """

    ENVIRON = ...

class Path:
    """Inspired to Django Two-scoops, handling File Paths in Settings."""

    def path(self, *paths, **kwargs):  # -> Path:
        """Create new Path based on self.root and provided paths.

        :param paths: List of sub paths
        :param kwargs: required=False
        :rtype: Path
        """
        ...
    def file(self, name, *args, **kwargs):
        r"""Open a file.

        :param str name: Filename appended to :py:attr:`~root`
        :param \*args: ``*args`` passed to :py:func:`open`
        :param \**kwargs: ``**kwargs`` passed to :py:func:`open`
        :rtype: typing.IO[typing.Any]
        """
        ...
    @property
    def root(self):
        """Current directory for this Path"""
        ...
    def __init__(self, start=..., *paths, **kwargs) -> None: ...
    def __call__(self, *paths, **kwargs):
        """Retrieve the absolute path, with appended paths

        :param paths: List of sub path of self.root
        :param kwargs: required=False
        """
        ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __invert__(self): ...
    def __contains__(self, item): ...
    def __repr__(self): ...
    def __str__(self) -> str: ...
    def __unicode__(self): ...
    def __getitem__(self, *args, **kwargs): ...
    def __fspath__(self): ...
    def rfind(self, *args, **kwargs):  # -> int:
        """Proxy method to :py:func:`str.rfind`"""
        ...
    def find(self, *args, **kwargs):  # -> int:
        """Proxy method to :py:func:`str.find`"""
        ...
