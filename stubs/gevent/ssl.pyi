"""
This type stub file was generated by pyright.
"""

import ssl as __ssl__
from gevent.socket import socket

"""SSL wrapper for socket objects on Python 3.

For the documentation, refer to :mod:`ssl` module manual.

This module implements cooperative SSL socket wrappers.
"""
_ssl = ...
__implements__ = ...
if hasattr(__ssl__, 'wrap_socket'):
    __extra__ = ...
else:
    __extra__ = ...
__imports__ = ...
__all__ = __implements__ + __imports__ + __extra__
if 'namedtuple' in __all__:
    ...
orig_SSLContext = __ssl__.SSLContext
class _contextawaresock(socket._gevent_sock_class):
    __slots__ = ...
    def __init__(self, family, type, proto, fileno, sslsocket_wref) -> None:
        ...
    


class _Callback:
    __slots__ = ...
    def __init__(self, user_function) -> None:
        ...
    
    def __call__(self, conn, *args):
        ...
    


class SSLContext(orig_SSLContext):
    __slots__ = ...
    sslsocket_class = ...
    def wrap_socket(self, sock, server_side=..., do_handshake_on_connect=..., suppress_ragged_eofs=..., server_hostname=..., session=...): # -> SSLSocket:
        ...
    
    if hasattr(orig_SSLContext.options, 'setter'):
        @orig_SSLContext.options.setter
        def options(self, value): # -> None:
            ...
        
        @orig_SSLContext.verify_flags.setter
        def verify_flags(self, value): # -> None:
            ...
        
        @orig_SSLContext.verify_mode.setter
        def verify_mode(self, value): # -> None:
            ...
        
    if hasattr(orig_SSLContext, 'minimum_version'):
        @orig_SSLContext.minimum_version.setter
        def minimum_version(self, value): # -> None:
            ...
        
        @orig_SSLContext.maximum_version.setter
        def maximum_version(self, value): # -> None:
            ...
        
    if hasattr(orig_SSLContext, '_msg_callback'):
        ...
    if hasattr(orig_SSLContext, 'sni_callback'):
        @property
        def sni_callback(self): # -> Unknown | ((SSLObject, str, SSLContext) -> (int | None)) | None:
            ...
        
        @sni_callback.setter
        def sni_callback(self, value): # -> None:
            ...
        
    else:
        def set_servername_callback(self, server_name_callback): # -> None:
            ...
        


class SSLSocket(socket):
    """
    gevent `ssl.SSLSocket
    <https://docs.python.org/3/library/ssl.html#ssl-sockets>`_ for
    Python 3.
    """
    def __init__(self, sock=..., keyfile=..., certfile=..., server_side=..., cert_reqs=..., ssl_version=..., ca_certs=..., do_handshake_on_connect=..., family=..., type=..., proto=..., fileno=..., suppress_ragged_eofs=..., npn_protocols=..., ciphers=..., server_hostname=..., _session=..., _context=...) -> None:
        ...
    
    @property
    def context(self): # -> SSLContext:
        ...
    
    @context.setter
    def context(self, ctx): # -> None:
        ...
    
    @property
    def session(self): # -> None:
        """The SSLSession for client socket."""
        ...
    
    @session.setter
    def session(self, session): # -> None:
        ...
    
    @property
    def session_reused(self): # -> None:
        """Was the client session reused during handshake"""
        ...
    
    def dup(self):
        ...
    
    def read(self, nbytes=..., buffer=...):
        """Read up to LEN bytes and return them.
        Return zero-length string on EOF."""
        ...
    
    def write(self, data):
        """Write DATA to the underlying SSL channel.  Returns
        number of bytes of DATA actually transmitted."""
        ...
    
    def getpeercert(self, binary_form=...):
        """Returns a formatted version of the data in the
        certificate provided by the other end of the SSL channel.
        Return None if no certificate was provided, {} if a
        certificate was provided, but not validated."""
        ...
    
    def selected_npn_protocol(self): # -> None:
        ...
    
    if hasattr(_ssl, 'HAS_ALPN'):
        def selected_alpn_protocol(self): # -> None:
            ...
        
        def shared_ciphers(self):
            """Return a list of ciphers shared by the client during the handshake or
            None if this is not a valid server connection.
            """
            ...
        
        def version(self): # -> None:
            """Return a string identifying the protocol version used by the
            current SSL channel. """
            ...
        
    def cipher(self): # -> None:
        ...
    
    def compression(self): # -> None:
        ...
    
    def send(self, data, flags=..., timeout=...): # -> Literal[0]:
        ...
    
    def sendto(self, data, flags_or_addr, addr=...):
        ...
    
    def sendmsg(self, *args, **kwargs):
        ...
    
    def sendall(self, data, flags=...):
        ...
    
    def recv(self, buflen=..., flags=...): # -> Literal[b""]:
        ...
    
    def recv_into(self, buffer, nbytes=..., flags=...):
        ...
    
    def recvfrom(self, buflen=..., flags=...):
        ...
    
    def recvfrom_into(self, buffer, nbytes=..., flags=...):
        ...
    
    def recvmsg(self, *args, **kwargs):
        ...
    
    def recvmsg_into(self, *args, **kwargs):
        ...
    
    def pending(self): # -> Literal[0]:
        ...
    
    def shutdown(self, how): # -> None:
        ...
    
    def unwrap(self): # -> Self@SSLSocket:
        ...
    
    def do_handshake(self): # -> None:
        """Perform a TLS/SSL handshake."""
        ...
    
    def connect(self, addr): # -> None:
        """Connects to remote ADDR, and then wraps the connection in
        an SSL channel."""
        ...
    
    def connect_ex(self, addr): # -> None:
        """Connects to remote ADDR, and then wraps the connection in
        an SSL channel."""
        ...
    
    def accept(self): # -> tuple[Unknown | SSLSocket, Unknown]:
        """
        Accepts a new connection from a remote client, and returns a
        tuple containing that new connection wrapped with a
        server-side SSL channel, and the address of the remote client.
        """
        ...
    
    def get_channel_binding(self, cb_type=...): # -> None:
        """Get channel binding data for current connection.  Raise ValueError
        if the requested `cb_type` is not supported.  Return bytes of the data
        or None if the data is not available (e.g. before the handshake).
        """
        ...
    
    def verify_client_post_handshake(self):
        ...
    


_SSLErrorReadTimeout = ...
_SSLErrorWriteTimeout = ...
_SSLErrorHandshakeTimeout = ...
def wrap_socket(sock, keyfile=..., certfile=..., server_side=..., cert_reqs=..., ssl_version=..., ca_certs=..., do_handshake_on_connect=..., suppress_ragged_eofs=..., ciphers=...): # -> SSLSocket:
    ...

def get_server_certificate(addr, ssl_version=..., ca_certs=...): # -> str:
    """Retrieve the certificate from the server at the specified address,
    and return it as a PEM-encoded string.
    If 'ca_certs' is specified, validate the server cert against it.
    If 'ssl_version' is specified, use it in the connection attempt."""
    ...

