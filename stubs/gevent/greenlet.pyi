"""
This type stub file was generated by pyright.
"""

from greenlet import greenlet
from gevent._compat import PYPY as _PYPY
from gevent._util import readproperty

__all__ = ['Greenlet', 'joinall', 'killall']
if _PYPY:
    _continulet = ...
class SpawnedLink:
    """
    A wrapper around link that calls it in another greenlet.

    Can be called only from main loop.
    """
    __slots__ = ...
    def __init__(self, callback) -> None:
        ...
    
    def __call__(self, source): # -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getattr__(self, item): # -> Any:
        ...
    


class SuccessSpawnedLink(SpawnedLink):
    """A wrapper around link that calls it in another greenlet only if source succeed.

    Can be called only from main loop.
    """
    __slots__ = ...
    def __call__(self, source): # -> None:
        ...
    


class FailureSpawnedLink(SpawnedLink):
    """A wrapper around link that calls it in another greenlet only if source failed.

    Can be called only from main loop.
    """
    __slots__ = ...
    def __call__(self, source): # -> None:
        ...
    


class _Frame:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    @property
    def f_globals(self): # -> None:
        ...
    


_greenlet__init__ = ...
class Greenlet(greenlet):
    """
    A light-weight cooperatively-scheduled execution unit.
    """
    spawning_stack_limit = ...
    def __init__(self, run=..., *args, **kwargs) -> None:
        """
        :param args: The arguments passed to the ``run`` function.
        :param kwargs: The keyword arguments passed to the ``run`` function.
        :keyword callable run: The callable object to run. If not given, this object's
            `_run` method will be invoked (typically defined by subclasses).

        .. versionchanged:: 1.1b1
            The ``run`` argument to the constructor is now verified to be a callable
            object. Previously, passing a non-callable object would fail after the greenlet
            was spawned.

        .. versionchanged:: 1.3b1
           The ``GEVENT_TRACK_GREENLET_TREE`` configuration value may be set to
           a false value to disable ``spawn_tree_locals``, ``spawning_greenlet``,
           and ``spawning_stack``. The first two will be None in that case, and the
           latter will be empty.

        .. versionchanged:: 1.5
           Greenlet objects are now more careful to verify that their ``parent`` is really
           a gevent hub, raising a ``TypeError`` earlier instead of an ``AttributeError`` later.

        .. versionchanged:: 20.12.1
           Greenlet objects now function as context managers. Exiting the ``with`` suite
           ensures that the greenlet has completed by :meth:`joining <join>`
           the greenlet (blocking, with
           no timeout). If the body of the suite raises an exception, the greenlet is
           :meth:`killed <kill>` with the default arguments and not joined in that case.
        """
        ...
    
    @property
    def minimal_ident(self):
        """
        A small, unique non-negative integer that identifies this object.

        This is similar to :attr:`threading.Thread.ident` (and `id`)
        in that as long as this object is alive, no other greenlet *in
        this hub* will have the same id, but it makes a stronger
        guarantee that the assigned values will be small and
        sequential. Sometime after this object has died, the value
        will be available for reuse.

        To get ids that are unique across all hubs, combine this with
        the hub's (``self.parent``) ``minimal_ident``.

        Accessing this property from threads other than the thread running
        this greenlet is not defined.

        .. versionadded:: 1.3a2

        """
        ...
    
    @readproperty
    def name(self): # -> LiteralString:
        """
        The greenlet name. By default, a unique name is constructed using
        the :attr:`minimal_ident`. You can assign a string to this
        value to change it. It is shown in the `repr` of this object if it
        has been assigned to or if the `minimal_ident` has already been generated.

        .. versionadded:: 1.3a2
        .. versionchanged:: 1.4
           Stop showing generated names in the `repr` when the ``minimal_ident``
           hasn't been requested. This reduces overhead and may be less confusing,
           since ``minimal_ident`` can get reused.
        """
        ...
    
    @property
    def loop(self):
        ...
    
    def __nonzero__(self): # -> bool:
        ...
    
    __bool__ = ...
    if _PYPY:
        @property
        def dead(self): # -> bool:
            "Boolean indicating that the greenlet is dead and will not run again."
            ...
        
    else:
        @property
        def dead(self): # -> bool:
            """
            Boolean indicating that the greenlet is dead and will not run again.

            This is true if:

            1. We were never started, but were :meth:`killed <kill>`
               immediately after creation (not possible with :meth:`spawn`); OR
            2. We were started, but were killed before running; OR
            3. We have run and terminated (by raising an exception out of the
               started function or by reaching the end of the started function).
            """
            ...
        
    @property
    def started(self): # -> bool:
        ...
    
    def ready(self): # -> bool:
        """
        Return a true value if and only if the greenlet has finished
        execution.

        .. versionchanged:: 1.1
            This function is only guaranteed to return true or false *values*, not
            necessarily the literal constants ``True`` or ``False``.
        """
        ...
    
    def successful(self): # -> bool:
        """
        Return a true value if and only if the greenlet has finished execution
        successfully, that is, without raising an error.

        .. tip:: A greenlet that has been killed with the default
            :class:`GreenletExit` exception is considered successful.
            That is, ``GreenletExit`` is not considered an error.

        .. note:: This function is only guaranteed to return true or false *values*,
              not necessarily the literal constants ``True`` or ``False``.
        """
        ...
    
    def __repr__(self): # -> str | Any:
        ...
    
    @property
    def exception(self): # -> None:
        """
        Holds the exception instance raised by the function if the
        greenlet has finished with an error. Otherwise ``None``.
        """
        ...
    
    @property
    def exc_info(self): # -> tuple[Unknown, Unknown, TracebackType | None] | None:
        """
        Holds the exc_info three-tuple raised by the function if the
        greenlet finished with an error. Otherwise a false value.

        .. note:: This is a provisional API and may change.

        .. versionadded:: 1.1
        """
        ...
    
    def throw(self, *args): # -> None:
        """Immediately switch into the greenlet and raise an exception in it.

        Should only be called from the HUB, otherwise the current greenlet is left unscheduled forever.
        To raise an exception in a safe manner from any greenlet, use :meth:`kill`.

        If a greenlet was started but never switched to yet, then also
        a) cancel the event that will start it
        b) fire the notifications as if an exception was raised in a greenlet
        """
        ...
    
    def start(self): # -> None:
        """Schedule the greenlet to run in this loop iteration"""
        ...
    
    def start_later(self, seconds): # -> None:
        """
        start_later(seconds) -> None

        Schedule the greenlet to run in the future loop iteration
        *seconds* later
        """
        ...
    
    @staticmethod
    def add_spawn_callback(callback): # -> None:
        """
        add_spawn_callback(callback) -> None

        Set up a *callback* to be invoked when :class:`Greenlet` objects
        are started.

        The invocation order of spawn callbacks is unspecified.  Adding the
        same callback more than one time will not cause it to be called more
        than once.

        .. versionadded:: 1.4.0
        """
        ...
    
    @staticmethod
    def remove_spawn_callback(callback): # -> None:
        """
        remove_spawn_callback(callback) -> None

        Remove *callback* function added with :meth:`Greenlet.add_spawn_callback`.
        This function will not fail if *callback* has been already removed or
        if *callback* was never added.

        .. versionadded:: 1.4.0
        """
        ...
    
    @classmethod
    def spawn(cls, *args, **kwargs): # -> Self@Greenlet:
        """
        spawn(function, *args, **kwargs) -> Greenlet

        Create a new :class:`Greenlet` object and schedule it to run ``function(*args, **kwargs)``.
        This can be used as ``gevent.spawn`` or ``Greenlet.spawn``.

        The arguments are passed to :meth:`Greenlet.__init__`.

        .. versionchanged:: 1.1b1
            If a *function* is given that is not callable, immediately raise a :exc:`TypeError`
            instead of spawning a greenlet that will raise an uncaught TypeError.
        """
        ...
    
    @classmethod
    def spawn_later(cls, seconds, *args, **kwargs): # -> Self@Greenlet:
        """
        spawn_later(seconds, function, *args, **kwargs) -> Greenlet

        Create and return a new `Greenlet` object scheduled to run ``function(*args, **kwargs)``
        in a future loop iteration *seconds* later. This can be used as ``Greenlet.spawn_later``
        or ``gevent.spawn_later``.

        The arguments are passed to :meth:`Greenlet.__init__`.

        .. versionchanged:: 1.1b1
           If an argument that's meant to be a function (the first argument in *args*, or the ``run`` keyword )
           is given to this classmethod (and not a classmethod of a subclass),
           it is verified to be callable. Previously, the spawned greenlet would have failed
           when it started running.
        """
        ...
    
    def kill(self, exception=..., block=..., timeout=...): # -> None:
        """
        Raise the ``exception`` in the greenlet.

        If ``block`` is ``True`` (the default), wait until the greenlet
        dies or the optional timeout expires; this may require switching
        greenlets.
        If block is ``False``, the current greenlet is not unscheduled.

        This function always returns ``None`` and never raises an error. It
        may be called multpile times on the same greenlet object, and may be
        called on an unstarted or dead greenlet.

        .. note::

            Depending on what this greenlet is executing and the state
            of the event loop, the exception may or may not be raised
            immediately when this greenlet resumes execution. It may
            be raised on a subsequent green call, or, if this greenlet
            exits before making such a call, it may not be raised at
            all. As of 1.1, an example where the exception is raised
            later is if this greenlet had called :func:`sleep(0)
            <gevent.sleep>`; an example where the exception is raised
            immediately is if this greenlet had called
            :func:`sleep(0.1) <gevent.sleep>`.

        .. caution::

            Use care when killing greenlets. If the code executing is not
            exception safe (e.g., makes proper use of ``finally``) then an
            unexpected exception could result in corrupted state. Using
            a :meth:`link` or :meth:`rawlink` (cheaper) may be a safer way to
            clean up resources.

        See also :func:`gevent.kill` and :func:`gevent.killall`.

        :keyword type exception: The type of exception to raise in the greenlet. The default
            is :class:`GreenletExit`, which indicates a :meth:`successful` completion
            of the greenlet.

        .. versionchanged:: 0.13.0
            *block* is now ``True`` by default.
        .. versionchanged:: 1.1a2
            If this greenlet had never been switched to, killing it will
            prevent it from *ever* being switched to. Links (:meth:`rawlink`)
            will still be executed, though.
        .. versionchanged:: 20.12.1
            If this greenlet is :meth:`ready`, immediately return instead of
            requiring a trip around the event loop.
        """
        ...
    
    def get(self, block=..., timeout=...): # -> None:
        """
        get(block=True, timeout=None) -> object

        Return the result the greenlet has returned or re-raise the
        exception it has raised.

        If block is ``False``, raise :class:`gevent.Timeout` if the
        greenlet is still alive. If block is ``True``, unschedule the
        current greenlet until the result is available or the timeout
        expires. In the latter case, :class:`gevent.Timeout` is
        raised.
        """
        ...
    
    def join(self, timeout=...): # -> None:
        """
        join(timeout=None) -> None

        Wait until the greenlet finishes or *timeout* expires. Return
        ``None`` regardless.
        """
        ...
    
    def __enter__(self): # -> Self@Greenlet:
        ...
    
    def __exit__(self, t, v, tb): # -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def has_links(self): # -> int:
        ...
    
    def rawlink(self, callback): # -> None:
        """
        Register a callable to be executed when the greenlet finishes
        execution.

        The *callback* will be called with this instance as an
        argument.

        The *callback* will be called even if linked after the greenlet
        is already ready().

        .. caution::
            The *callback* will be called in the hub and
            **MUST NOT** raise an exception.
        """
        ...
    
    def link(self, callback, SpawnedLink=...): # -> None:
        """
        Link greenlet's completion to a callable.

        The *callback* will be called with this instance as an
        argument once this greenlet is dead. A callable is called in
        its own :class:`greenlet.greenlet` (*not* a
        :class:`Greenlet`).

        The *callback* will be called even if linked after the greenlet
        is already ready().
        """
        ...
    
    def unlink(self, callback): # -> None:
        """Remove the callback set by :meth:`link` or :meth:`rawlink`"""
        ...
    
    def unlink_all(self): # -> None:
        """
        Remove all the callbacks.

        .. versionadded:: 1.3a2
        """
        ...
    
    def link_value(self, callback, SpawnedLink=...): # -> None:
        """
        Like :meth:`link` but *callback* is only notified when the greenlet
        has completed successfully.
        """
        ...
    
    def link_exception(self, callback, SpawnedLink=...): # -> None:
        """
        Like :meth:`link` but *callback* is only notified when the
        greenlet dies because of an unhandled exception.
        """
        ...
    


class _dummy_event:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def stop(self): # -> None:
        ...
    
    def start(self, cb):
        ...
    
    def close(self): # -> None:
        ...
    


_cancelled_start_event = ...
_start_completed_event = ...
def joinall(greenlets, timeout=..., raise_error=..., count=...): # -> list[Unknown]:
    """
    Wait for the ``greenlets`` to finish.

    :param greenlets: A sequence (supporting :func:`len`) of greenlets to wait for.
    :keyword float timeout: If given, the maximum number of seconds to wait.
    :return: A sequence of the greenlets that finished before the timeout (if any)
        expired.
    """
    ...

_spawn_callbacks = ...
def killall(greenlets, exception=..., block=..., timeout=...): # -> None:
    """
    Forceably terminate all the *greenlets* by causing them to raise *exception*.

    .. caution:: Use care when killing greenlets. If they are not prepared for exceptions,
       this could result in corrupted state.

    :param greenlets: A **bounded** iterable of the non-None greenlets to terminate.
       *All* the items in this iterable must be greenlets that belong to the same hub,
       which should be the hub for this current thread. If this is a generator or iterator
       that switches greenlets, the results are undefined.
    :keyword exception: The type of exception to raise in the greenlets. By default this is
        :class:`GreenletExit`.
    :keyword bool block: If True (the default) then this function only returns when all the
        greenlets are dead; the current greenlet is unscheduled during that process.
        If greenlets ignore the initial exception raised in them,
        then they will be joined (with :func:`gevent.joinall`) and allowed to die naturally.
        If False, this function returns immediately and greenlets will raise
        the exception asynchronously.
    :keyword float timeout: A time in seconds to wait for greenlets to die. If given, it is
        only honored when ``block`` is True.
    :raise Timeout: If blocking and a timeout is given that elapses before
        all the greenlets are dead.

    .. versionchanged:: 1.1a2
        *greenlets* can be any iterable of greenlets, like an iterator or a set.
        Previously it had to be a list or tuple.
    .. versionchanged:: 1.5a3
        Any :class:`Greenlet` in the *greenlets* list that hadn't been switched to before
        calling this method will never be switched to. This makes this function
        behave like :meth:`Greenlet.kill`. This does not apply to raw greenlets.
    .. versionchanged:: 1.5a3
        Now accepts raw greenlets created by :func:`gevent.spawn_raw`.
    """
    ...

