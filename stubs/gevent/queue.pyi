"""
This type stub file was generated by pyright.
"""

import sys
import queue as __queue__

"""
Synchronized queues.

The :mod:`gevent.queue` module implements multi-producer, multi-consumer queues
that work across greenlets, with the API similar to the classes found in the
standard :mod:`Queue` and :class:`multiprocessing <multiprocessing.Queue>` modules.

The classes in this module implement the iterator protocol. Iterating
over a queue means repeatedly calling :meth:`get <Queue.get>` until
:meth:`get <Queue.get>` returns ``StopIteration`` (specifically that
class, not an instance or subclass).

    >>> import gevent.queue
    >>> queue = gevent.queue.Queue()
    >>> queue.put(1)
    >>> queue.put(2)
    >>> queue.put(StopIteration)
    >>> for item in queue:
    ...    print(item)
    1
    2

.. versionchanged:: 1.0
       ``Queue(0)`` now means queue of infinite size, not a channel. A :exc:`DeprecationWarning`
       will be issued with this argument.
"""
if sys.version_info[0] == 2:
    ...
else:
    ...
Full = _Full = __queue__.Full
Empty = _Empty = __queue__.Empty
__all__ = []
__implements__ = ...
__extensions__ = ...
__imports__ = ...
if hasattr(__queue__, 'SimpleQueue'):
    SimpleQueue = ...
__all__ += (__implements__ + __extensions__ + __imports__)
class ItemWaiter(Waiter):
    __slots__ = ...
    def __init__(self, item, queue) -> None:
        ...
    
    def put_and_switch(self):
        ...
    


class Queue:
    """
    Create a queue object with a given maximum size.

    If *maxsize* is less than or equal to zero or ``None``, the queue
    size is infinite.

    Queues have a ``len`` equal to the number of items in them (the :meth:`qsize`),
    but in a boolean context they are always True.

    .. versionchanged:: 1.1b3
       Queues now support :func:`len`; it behaves the same as :meth:`qsize`.
    .. versionchanged:: 1.1b3
       Multiple greenlets that block on a call to :meth:`put` for a full queue
       will now be awakened to put their items into the queue in the order in which
       they arrived. Likewise, multiple greenlets that block on a call to :meth:`get` for
       an empty queue will now receive items in the order in which they blocked. An
       implementation quirk under CPython *usually* ensured this was roughly the case
       previously anyway, but that wasn't the case for PyPy.
    """
    __slots__ = ...
    def __init__(self, maxsize=..., items=..., _warn_depth=...) -> None:
        ...
    
    @property
    def maxsize(self): # -> int | None:
        ...
    
    @maxsize.setter
    def maxsize(self, nv): # -> None:
        ...
    
    def copy(self): # -> Self@Queue:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def qsize(self): # -> int:
        """Return the size of the queue."""
        ...
    
    def __len__(self): # -> int:
        """
        Return the size of the queue. This is the same as :meth:`qsize`.

        .. versionadded: 1.1b3

            Previously, getting len() of a queue would raise a TypeError.
        """
        ...
    
    def __bool__(self): # -> Literal[True]:
        """
        A queue object is always True.

        .. versionadded: 1.1b3

           Now that queues support len(), they need to implement ``__bool__``
           to return True for backwards compatibility.
        """
        ...
    
    def __nonzero__(self): # -> Literal[True]:
        ...
    
    def empty(self): # -> bool:
        """Return ``True`` if the queue is empty, ``False`` otherwise."""
        ...
    
    def full(self): # -> bool:
        """Return ``True`` if the queue is full, ``False`` otherwise.

        ``Queue(None)`` is never full.
        """
        ...
    
    def put(self, item, block=..., timeout=...): # -> None:
        """Put an item into the queue.

        If optional arg *block* is true and *timeout* is ``None`` (the default),
        block if necessary until a free slot is available. If *timeout* is
        a positive number, it blocks at most *timeout* seconds and raises
        the :class:`Full` exception if no free slot was available within that time.
        Otherwise (*block* is false), put an item on the queue if a free slot
        is immediately available, else raise the :class:`Full` exception (*timeout*
        is ignored in that case).
        """
        ...
    
    def put_nowait(self, item): # -> None:
        """Put an item into the queue without blocking.

        Only enqueue the item if a free slot is immediately available.
        Otherwise raise the :class:`Full` exception.
        """
        ...
    
    def get(self, block=..., timeout=...):
        """Remove and return an item from the queue.

        If optional args *block* is true and *timeout* is ``None`` (the default),
        block if necessary until an item is available. If *timeout* is a positive number,
        it blocks at most *timeout* seconds and raises the :class:`Empty` exception
        if no item was available within that time. Otherwise (*block* is false), return
        an item if one is immediately available, else raise the :class:`Empty` exception
        (*timeout* is ignored in that case).
        """
        ...
    
    def get_nowait(self):
        """Remove and return an item from the queue without blocking.

        Only get an item if one is immediately available. Otherwise
        raise the :class:`Empty` exception.
        """
        ...
    
    def peek(self, block=..., timeout=...):
        """Return an item from the queue without removing it.

        If optional args *block* is true and *timeout* is ``None`` (the default),
        block if necessary until an item is available. If *timeout* is a positive number,
        it blocks at most *timeout* seconds and raises the :class:`Empty` exception
        if no item was available within that time. Otherwise (*block* is false), return
        an item if one is immediately available, else raise the :class:`Empty` exception
        (*timeout* is ignored in that case).
        """
        ...
    
    def peek_nowait(self):
        """Return an item from the queue without blocking.

        Only return an item if one is immediately available. Otherwise
        raise the :class:`Empty` exception.
        """
        ...
    
    def __iter__(self): # -> Self@Queue:
        ...
    
    def __next__(self):
        ...
    
    next = ...


class UnboundQueue(Queue):
    __slots__ = ...
    def __init__(self, maxsize=..., items=...) -> None:
        ...
    
    def put(self, item, block=..., timeout=...): # -> None:
        ...
    


class PriorityQueue(Queue):
    '''A subclass of :class:`Queue` that retrieves entries in priority order (lowest first).

    Entries are typically tuples of the form: ``(priority number, data)``.

    .. versionchanged:: 1.2a1
       Any *items* given to the constructor will now be passed through
       :func:`heapq.heapify` to ensure the invariants of this class hold.
       Previously it was just assumed that they were already a heap.
    '''
    __slots__ = ...


class LifoQueue(Queue):
    '''A subclass of :class:`Queue` that retrieves most recently added entries first.'''
    __slots__ = ...


class JoinableQueue(Queue):
    """
    A subclass of :class:`Queue` that additionally has
    :meth:`task_done` and :meth:`join` methods.
    """
    __slots__ = ...
    def __init__(self, maxsize=..., items=..., unfinished_tasks=...) -> None:
        """

        .. versionchanged:: 1.1a1
           If *unfinished_tasks* is not given, then all the given *items*
           (if any) will be considered unfinished.

        """
        ...
    
    def copy(self): # -> Self@JoinableQueue:
        ...
    
    def task_done(self): # -> None:
        '''Indicate that a formerly enqueued task is complete. Used by queue consumer threads.
        For each :meth:`get <Queue.get>` used to fetch a task, a subsequent call to :meth:`task_done` tells the queue
        that the processing on the task is complete.

        If a :meth:`join` is currently blocking, it will resume when all items have been processed
        (meaning that a :meth:`task_done` call was received for every item that had been
        :meth:`put <Queue.put>` into the queue).

        Raises a :exc:`ValueError` if called more times than there were items placed in the queue.
        '''
        ...
    
    def join(self, timeout=...):
        '''
        Block until all items in the queue have been gotten and processed.

        The count of unfinished tasks goes up whenever an item is added to the queue.
        The count goes down whenever a consumer thread calls :meth:`task_done` to indicate
        that the item was retrieved and all work on it is complete. When the count of
        unfinished tasks drops to zero, :meth:`join` unblocks.

        :param float timeout: If not ``None``, then wait no more than this time in seconds
            for all tasks to finish.
        :return: ``True`` if all tasks have finished; if ``timeout`` was given and expired before
            all tasks finished, ``False``.

        .. versionchanged:: 1.1a1
           Add the *timeout* parameter.
        '''
        ...
    


class Channel:
    __slots__ = ...
    def __init__(self, maxsize=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    @property
    def balance(self): # -> int:
        ...
    
    def qsize(self): # -> Literal[0]:
        ...
    
    def empty(self): # -> Literal[True]:
        ...
    
    def full(self): # -> Literal[True]:
        ...
    
    def put(self, item, block=..., timeout=...): # -> None:
        ...
    
    def put_nowait(self, item): # -> None:
        ...
    
    def get(self, block=..., timeout=...):
        ...
    
    def get_nowait(self):
        ...
    
    def __iter__(self): # -> Self@Channel:
        ...
    
    def __next__(self):
        ...
    
    next = ...


