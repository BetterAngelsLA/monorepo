"""
This type stub file was generated by pyright.
"""

from collections.abc import Mapping
from gevent._util import _NONE
from gevent.local import local

"""
Cooperative ``contextvars`` module.

This module was added to Python 3.7. The gevent version is available
on all supported versions of Python. However, see an important note
about gevent 20.9.

Context variables are like greenlet-local variables, just more
inconvenient to use. They were designed to work around limitations in
:mod:`asyncio` and are rarely needed by greenlet-based code.

The primary difference is that snapshots of the state of all context
variables in a given greenlet can be taken, and later restored for
execution; modifications to context variables are "scoped" to the
duration that a particular context is active. (This state-restoration
support is rarely useful for greenlets because instead of always
running "tasks" sequentially within a single thread like `asyncio`
does, greenlet-based code usually spawns new greenlets to handle each
task.)

The gevent implementation is based on the Python reference implementation
from :pep:`567` and doesn't have much optimization. In particular, setting
context values isn't constant time.

.. versionadded:: 1.5a3
.. versionchanged:: 20.9.0
   On Python 3.7 and above, this module is no longer monkey-patched
   in place of the standard library version.
   gevent depends on greenlet 0.4.17 which includes support for context variables.
   This means that any number of greenlets can be running any number of asyncio tasks
   each with their own context variables. This module is only greenlet aware, not
   asyncio task aware, so its use is not recommended on Python 3.7 and above.

   On previous versions of Python, this module continues to be a solution for
   backporting code. It is also available if you wish to use the contextvar API
   in a strictly greenlet-local manner.
"""
__all__ = ['ContextVar', 'Context', 'copy_context', 'Token']
__stdlib_expected__ = ...
__implements__ = ...
class _ContextState(local):
    def __init__(self) -> None:
        ...
    


class _ContextData:
    """
    A copy-on-write immutable mapping from ContextVar
    keys to arbitrary values. Setting values requires a
    copy, making it O(n), not O(1).
    """
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def set(self, key, value): # -> _ContextData:
        ...
    
    def delete(self, key): # -> _ContextData:
        ...
    


class ContextVar:
    """
    Implementation of :class:`contextvars.ContextVar`.
    """
    __slots__ = ...
    def __init__(self, name, default=...) -> None:
        ...
    
    __init_subclass__ = ...
    @classmethod
    def __class_getitem__(cls, _): # -> type[Self@ContextVar]:
        ...
    
    @property
    def name(self): # -> Unknown:
        ...
    
    def get(self, default=...): # -> type[_NONE]:
        ...
    
    def set(self, value): # -> Token:
        ...
    
    def reset(self, token): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Token:
    """
    Opaque implementation of :class:`contextvars.Token`.
    """
    MISSING = _NONE
    __slots__ = ...
    def __init__(self, context, var, old_value) -> None:
        ...
    
    __init_subclass__ = ...
    @property
    def var(self): # -> Unknown:
        """
        A read-only attribute pointing to the variable that created the token
        """
        ...
    
    @property
    def old_value(self): # -> Unknown:
        """
        A read-only attribute set to the value the variable had before
        the ``set()`` call, or to :attr:`MISSING` if the variable wasn't set
        before.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Context(Mapping):
    """
    Implementation of :class:`contextvars.Context`
    """
    __slots__ = ...
    def __init__(self) -> None:
        """
        Creates an empty context.
        """
        ...
    
    __init_subclass__ = ...
    def run(self, function, *args, **kwargs):
        ...
    
    def copy(self): # -> Context:
        """
        Return a shallow copy.
        """
        ...
    
    def __getitem__(self, key):
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    


def copy_context(): # -> Context:
    """
    Return a shallow copy of the current context.
    """
    ...

_context_state = ...
