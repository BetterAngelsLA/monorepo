"""
This type stub file was generated by pyright.
"""

MAPPING = ...
OPTIONAL_STDLIB_MODULES = ...
_PATCH_PREFIX = ...
class _SysModulesPatcher:
    def __init__(self, importing, extra_all=...) -> None:
        ...
    
    def __exit__(self, t, v, tb): # -> None:
        ...
    
    def __enter__(self): # -> Self@_SysModulesPatcher:
        ...
    
    module = ...
    def __call__(self, after_import_hook): # -> Self@_SysModulesPatcher:
        ...
    
    def import_one(self, module_name, after_import_hook): # -> ModuleType | Any:
        ...
    


def import_patched(module_name, extra_all=..., after_import_hook=...): # -> _SysModulesPatcher:
    """
    Import *module_name* with gevent monkey-patches active,
    and return an object holding the greened module as *module*.

    Any sub-modules that were imported by the package are also
    saved.

    .. versionchanged:: 1.5a4
       If the module defines ``__all__``, then each of those
       attributes/modules is also imported as part of the same transaction,
       recursively. The order of ``__all__`` is respected. Anything passed in
       *extra_all* (which must be in the same namespace tree) is also imported.

    .. versionchanged:: 1.5a4
       You must now do all patching for a given module tree
       with one call to this method, or at least by using the returned
       object.
    """
    ...

class cached_platform_architecture:
    """
    Context manager that caches ``platform.architecture``.

    Some things that load shared libraries (like Cryptodome, via
    dnspython) invoke ``platform.architecture()`` for each one. That
    in turn wants to fork and run commands , which in turn wants to
    call ``threading._after_fork`` if the GIL has been initialized.
    All of that means that certain imports done early may wind up
    wanting to have the hub initialized potentially much earlier than
    before.

    Part of the fix is to observe when that happens and delay
    initializing parts of gevent until as late as possible (e.g., we
    delay importing and creating the resolver until the hub needs it,
    unless explicitly configured).

    The rest of the fix is to avoid the ``_after_fork`` issues by
    first caching the results of platform.architecture before doing
    patched imports.

    (See events.py for similar issues with platform, and
    test__threading_2.py for notes about threading._after_fork if the
    GIL has been initialized)
    """
    _arch_result = ...
    _orig_arch = ...
    _platform = ...
    def __enter__(self): # -> Self@cached_platform_architecture:
        ...
    
    def __exit__(self, *_args): # -> None:
        ...
    


