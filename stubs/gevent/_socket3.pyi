"""
This type stub file was generated by pyright.
"""

import os
import _socket
from gevent import _socketcommon
from gevent._compat import PYPY

"""
Python 3 socket module.
"""
__socket__ = _socketcommon.__socket__
__implements__ = ...
__extensions__ = ...
__imports__ = ...
__dns__ = ...
SocketIO = __socket__.SocketIO
class _closedsocket:
    __slots__ = ...
    def __init__(self, family, type, proto, orig_fileno, description) -> None:
        ...
    
    def fileno(self): # -> Literal[-1]:
        ...
    
    def close(self): # -> None:
        "No-op"
        ...
    
    detach = ...
    recvfrom_into = ...
    getsockname = ...
    def __bool__(self): # -> Literal[False]:
        ...
    
    __getattr__ = ...
    def __repr__(self): # -> str:
        ...
    


class _wrefsocket(_socket.socket):
    __slots__ = ...
    if PYPY:
        timeout = ...


class socket(_socketcommon.SocketMixin):
    """
    gevent `socket.socket <https://docs.python.org/3/library/socket.html#socket-objects>`_
    for Python 3.

    This object should have the same API as the standard library socket linked to above. Not all
    methods are specifically documented here; when they are they may point out a difference
    to be aware of or may document a method the standard library does not.
    """
    _gevent_sock_class = _wrefsocket
    __slots__ = ...
    def __init__(self, family=..., type=..., proto=..., fileno=...) -> None:
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    if hasattr(_socket, 'SOCK_NONBLOCK'):
        @property
        def type(self): # -> int:
            ...
        
    def __enter__(self): # -> Self@socket:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    
    def __repr__(self): # -> str:
        """Wrap __repr__() to reveal the real class name."""
        ...
    
    def __getstate__(self):
        ...
    
    def dup(self): # -> socket:
        """dup() -> socket object

        Return a new socket object connected to the same system resource.
        """
        ...
    
    def accept(self): # -> tuple[socket, Unknown]:
        """accept() -> (socket object, address info)

        Wait for an incoming connection.  Return a new socket
        representing the connection, and the address of the client.
        For IP sockets, the address info is a pair (hostaddr, port).
        """
        ...
    
    def makefile(self, mode=..., buffering=..., *, encoding=..., errors=..., newline=...): # -> SocketIO | BufferedRWPair | BufferedReader | BufferedWriter | TextIOWrapper:
        """Return an I/O stream connected to the socket

        The arguments are as for io.open() after the filename,
        except the only mode characters supported are 'r', 'w' and 'b'.
        The semantics are similar too.
        """
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def closed(self): # -> bool:
        ...
    
    def detach(self): # -> int:
        """
        detach() -> file descriptor

        Close the socket object without closing the underlying file
        descriptor. The object cannot be used after this call; when the
        real file descriptor is closed, the number that was previously
        used here may be reused. The fileno() method, after this call,
        will return an invalid socket id.

        The previous descriptor is returned.

        .. versionchanged:: 1.5

           Also immediately drop any native event loop resources.
        """
        ...
    
    if hasattr(_socket.socket, 'recvmsg'):
        def recvmsg(self, *args): # -> tuple[bytes, list[_CMSG], int, Any]:
            ...
        
    if hasattr(_socket.socket, 'recvmsg_into'):
        def recvmsg_into(self, buffers, *args): # -> tuple[int, list[_CMSG], int, Any]:
            ...
        
    if hasattr(_socket.socket, 'sendmsg'):
        def sendmsg(self, buffers, ancdata=..., flags=..., address=...): # -> int:
            ...
        
    def sendfile(self, file, offset=..., count=...): # -> int:
        """sendfile(file[, offset[, count]]) -> sent

        Send a file until EOF is reached by using high-performance
        os.sendfile() and return the total number of bytes which
        were sent.
        *file* must be a regular file object opened in binary mode.
        If os.sendfile() is not available (e.g. Windows) or file is
        not a regular file socket.send() will be used instead.
        *offset* tells from where to start reading the file.
        If specified, *count* is the total number of bytes to transmit
        as opposed to sending the file until EOF is reached.
        File position is updated on return or also in case of error in
        which case file.tell() can be used to figure out the number of
        bytes which were sent.
        The socket must be of SOCK_STREAM type.
        Non-blocking sockets are not supported.

        .. versionadded:: 1.1rc4
           Added in Python 3.5, but available under all Python 3 versions in
           gevent.
        """
        ...
    
    if os.name == 'nt':
        ...
    else:
        def get_inheritable(self): # -> bool:
            ...
        
        def set_inheritable(self, inheritable): # -> None:
            ...
        


SocketType = socket
def fromfd(fd, family, type, proto=...): # -> socket:
    """ fromfd(fd, family, type[, proto]) -> socket object

    Create a socket object from a duplicate of the given file
    descriptor.  The remaining arguments are the same as for socket().
    """
    ...

if hasattr(_socket.socket, "share"):
    def fromshare(info): # -> socket:
        """ fromshare(info) -> socket object

        Create a socket object from a the bytes object returned by
        socket.share(pid).
        """
        ...
    
if hasattr(_socket, "socketpair"):
    def socketpair(family=..., type=..., proto=...): # -> tuple[socket, socket]:
        """socketpair([family[, type[, proto]]]) -> (socket object, socket object)

        Create a pair of socket objects from the sockets returned by the platform
        socketpair() function.
        The arguments are the same as for socket() except the default family is
        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.

        .. versionchanged:: 1.2
           All Python 3 versions on Windows supply this function (natively
           supplied by Python 3.5 and above).
        """
        ...
    
else:
    _LOCALHOST = ...
    _LOCALHOST_V6 = ...
    def socketpair(family=..., type=..., proto=...): # -> tuple[socket, socket]:
        ...
    
__all__ = __implements__ + __extensions__ + __imports__
__version_specific__ = ...
