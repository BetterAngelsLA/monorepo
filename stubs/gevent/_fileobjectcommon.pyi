"""
This type stub file was generated by pyright.
"""

import io

"""
gevent internals.
"""
class cancel_wait_ex(IOError):
    def __init__(self) -> None:
        ...
    


class FileObjectClosed(IOError):
    def __init__(self) -> None:
        ...
    


class UniversalNewlineBytesWrapper(io.TextIOWrapper):
    """
    Uses TextWrapper to decode universal newlines, but returns the
    results as bytes.

    This is for Python 2 where the 'rU' mode did that.
    """
    mode = ...
    def __init__(self, fobj, line_buffering) -> None:
        ...
    
    def read(self, *args, **kwargs): # -> bytes:
        ...
    
    def readline(self, limit=...): # -> bytes:
        ...
    
    def __iter__(self): # -> Self@UniversalNewlineBytesWrapper:
        ...
    
    def __next__(self): # -> bytes:
        ...
    
    next = ...


class FlushingBufferedWriter(io.BufferedWriter):
    def write(self, b): # -> int:
        ...
    


class WriteallMixin:
    def writeall(self, value): # -> int:
        """
        Similar to :meth:`socket.socket.sendall`, ensures that all the contents of
        *value* have been written (though not necessarily flushed) before returning.

        Returns the length of *value*.

        .. versionadded:: 20.12.0
        """
        ...
    


class FileIO(io.FileIO):
    """A subclass that we can dynamically assign __class__ for."""
    __slots__ = ...


class WriteIsWriteallMixin(WriteallMixin):
    def write(self, value): # -> int:
        ...
    


class WriteallFileIO(WriteIsWriteallMixin, io.FileIO):
    ...


class OpenDescriptor:
    """
    Interprets the arguments to `open`. Internal use only.

    Originally based on code in the stdlib's _pyio.py (Python implementation of
    the :mod:`io` module), but modified for gevent:

    - Native strings are returned on Python 2 when neither
      'b' nor 't' are in the mode string and no encoding is specified.
    - Universal newlines work in that mode.
    - Allows externally unbuffered text IO.

    :keyword bool atomic_write: If true, then if the opened, wrapped, stream
        is unbuffered (meaning that ``write`` can produce short writes and the return
        value needs to be checked), then the implementation will be adjusted so that
        ``write`` behaves like Python 2 on a built-in file object and writes the
        entire value. Only set this on Python 2; the only intended user is
        :class:`gevent.subprocess.Popen`.
    """
    def __init__(self, fobj, mode=..., bufsize=..., close=..., encoding=..., errors=..., newline=..., buffering=..., closefd=..., atomic_write=...) -> None:
        ...
    
    default_buffer_size = ...
    _opened = ...
    _opened_raw = ...
    def is_fd(self): # -> bool:
        ...
    
    def opened(self): # -> TextIOWrapper | BufferedRandom | BufferedWriter | BufferedReader | WriteIsWriteallMixin:
        """
        Return the :meth:`wrapped` file object.
        """
        ...
    
    def opened_raw(self): # -> str | int | Unknown | FileIO:
        ...
    
    @staticmethod
    def is_buffered(stream): # -> bool:
        ...
    
    @classmethod
    def buffer_size_for_stream(cls, stream): # -> int:
        ...
    


class _ClosedIO:
    __slots__ = ...
    def __init__(self, io_obj) -> None:
        ...
    
    def __getattr__(self, name):
        ...
    
    def __bool__(self): # -> Literal[False]:
        ...
    
    __nonzero__ = ...


class FileObjectBase:
    """
    Internal base class to ensure a level of consistency
    between :class:`~.FileObjectPosix`, :class:`~.FileObjectThread`
    and :class:`~.FileObjectBlock`.
    """
    _delegate_methods = ...
    _io = ...
    def __init__(self, descriptor: OpenDescriptor) -> None:
        ...
    
    io = ...
    @property
    def closed(self): # -> bool:
        """True if the file is closed"""
        ...
    
    def close(self): # -> None:
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __enter__(self): # -> Self@FileObjectBase:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    
    def __iter__(self): # -> Self@FileObjectBase:
        ...
    
    def __next__(self): # -> Any:
        ...
    
    next = ...
    def __bool__(self): # -> Literal[True]:
        ...
    
    __nonzero__ = ...


class FileObjectBlock(FileObjectBase):
    """
    FileObjectBlock()

    A simple synchronous wrapper around a file object.

    Adds no concurrency or gevent compatibility.
    """
    def __init__(self, fobj, *args, **kwargs) -> None:
        ...
    


class FileObjectThread(FileObjectBase):
    """
    FileObjectThread()

    A file-like object wrapping another file-like object, performing all blocking
    operations on that object in a background thread.

    .. caution::
        Attempting to change the threadpool or lock of an existing FileObjectThread
        has undefined consequences.

    .. versionchanged:: 1.1b1
       The file object is closed using the threadpool. Note that whether or
       not this action is synchronous or asynchronous is not documented.
    """
    def __init__(self, *args, **kwargs) -> None:
        """
        :keyword bool lock: If True (the default) then all operations will
           be performed one-by-one. Note that this does not guarantee that, if using
           this file object from multiple threads/greenlets, operations will be performed
           in any particular order, only that no two operations will be attempted at the
           same time. You can also pass your own :class:`gevent.lock.Semaphore` to synchronize
           file operations with an external resource.
        :keyword bool closefd: If True (the default) then when this object is closed,
           the underlying object is closed as well. If *fobj* is a path, then
           *closefd* must be True.
        """
        ...
    


