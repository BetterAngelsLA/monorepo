"""
This type stub file was generated by pyright.
"""

from gevent._compat import PURE_PYTHON
from gevent._semaphore import BoundedSemaphore, Semaphore

"""
Locking primitives.

These include semaphores with arbitrary bounds (:class:`Semaphore` and
its safer subclass :class:`BoundedSemaphore`) and a semaphore with
infinite bounds (:class:`DummySemaphore`), along with a reentrant lock
(:class:`RLock`) with the same API as :class:`threading.RLock`.
"""
__all__ = ['Semaphore', 'BoundedSemaphore', 'DummySemaphore', 'RLock']
def atomic(meth): # -> (self: Unknown, *args: Unknown) -> Unknown:
    ...

class _GILLock:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    @atomic
    def acquire(self): # -> Literal[True]:
        ...
    
    @atomic
    def release(self): # -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, t, v, tb): # -> None:
        ...
    
    def locked(self):
        ...
    


class _AtomicSemaphoreMixin:
    __slots__ = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def release(self):
        ...
    
    def acquire(self, blocking=..., timeout=...):
        ...
    
    _py3k_acquire = ...
    def wait(self, timeout=...):
        ...
    


class _AtomicSemaphore(_AtomicSemaphoreMixin, Semaphore):
    __doc__ = ...
    __slots__ = ...


class _AtomicBoundedSemaphore(_AtomicSemaphoreMixin, BoundedSemaphore):
    __doc__ = ...
    __slots__ = ...
    def release(self):
        ...
    


if PURE_PYTHON:
    Semaphore = ...
    BoundedSemaphore = ...
class DummySemaphore:
    """
    DummySemaphore(value=None) -> DummySemaphore

    An object with the same API as :class:`Semaphore`,
    initialized with "infinite" initial value. None of its
    methods ever block.

    This can be used to parameterize on whether or not to actually
    guard access to a potentially limited resource. If the resource is
    actually limited, such as a fixed-size thread pool, use a real
    :class:`Semaphore`, but if the resource is unbounded, use an
    instance of this class. In that way none of the supporting code
    needs to change.

    Similarly, it can be used to parameterize on whether or not to
    enforce mutual exclusion to some underlying object. If the
    underlying object is known to be thread-safe itself mutual
    exclusion is not needed and a ``DummySemaphore`` can be used, but
    if that's not true, use a real ``Semaphore``.
    """
    def __init__(self, value=...) -> None:
        """
        .. versionchanged:: 1.1rc3
            Accept and ignore a *value* argument for compatibility with Semaphore.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def locked(self): # -> Literal[False]:
        """A DummySemaphore is never locked so this always returns False."""
        ...
    
    def ready(self): # -> Literal[True]:
        """A DummySemaphore is never locked so this always returns True."""
        ...
    
    def release(self): # -> None:
        """Releasing a dummy semaphore does nothing."""
        ...
    
    def rawlink(self, callback): # -> None:
        ...
    
    def unlink(self, callback): # -> None:
        ...
    
    def wait(self, timeout=...): # -> Literal[1]:
        """Waiting for a DummySemaphore returns immediately."""
        ...
    
    def acquire(self, blocking=..., timeout=...): # -> Literal[True]:
        """
        A DummySemaphore can always be acquired immediately so this always
        returns True and ignores its arguments.

        .. versionchanged:: 1.1a1
           Always return *true*.
        """
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, typ, val, tb): # -> None:
        ...
    


class RLock:
    """
    A mutex that can be acquired more than once by the same greenlet.

    A mutex can only be locked by one greenlet at a time. A single greenlet
    can `acquire` the mutex as many times as desired, though. Each call to
    `acquire` must be paired with a matching call to `release`.

    It is an error for a greenlet that has not acquired the mutex
    to release it.

    Instances are context managers.
    """
    __slots__ = ...
    def __init__(self, hub=...) -> None:
        """
        .. versionchanged:: 20.5.1
           Add the ``hub`` argument.
        """
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def acquire(self, blocking=..., timeout=...): # -> bool | Literal[1] | None:
        """
        Acquire the mutex, blocking if *blocking* is true, for up to
        *timeout* seconds.

        .. versionchanged:: 1.5a4
           Added the *timeout* parameter.

        :return: A boolean indicating whether the mutex was acquired.
        """
        ...
    
    def __enter__(self): # -> bool | Literal[1] | None:
        ...
    
    def release(self): # -> None:
        """
        Release the mutex.

        Only the greenlet that originally acquired the mutex can
        release it.
        """
        ...
    
    def __exit__(self, typ, value, tb): # -> None:
        ...
    


